## ejemplo de pipeline utilizando python y github


Una canalizaci√≥n o pipeline es una serie de etapas automatizadas que un desarrollador de software utiliza para entregar c√≥digo nuevo. Este proceso, a menudo llamado Integraci√≥n Continua/Despliegue Continuo (CI/CD), garantiza que el c√≥digo sea probado, construido y desplegado de manera eficiente y confiable. ü§ñ

Ejemplo de Pipeline con Python y GitHub Actions
A continuaci√≥n, te muestro un ejemplo sencillo de c√≥mo configurar una pipeline CI/CD en un proyecto de Python usando GitHub Actions. Este pipeline se activar√° autom√°ticamente cada vez que se haga un push o una pull request a la rama main.

1. Requisitos
Antes de empezar, necesitar√°s:

Un repositorio en GitHub.

Un proyecto de Python en ese repositorio.

Un archivo de requisitos (requirements.txt).

Alg√∫n test unitario, por ejemplo, usando la biblioteca unittest o pytest.

2. Estructura del proyecto
La estructura de tu proyecto de Python deber√≠a ser similar a esta:
```
mi_proyecto_python/
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ python_ci.yml  # Aqu√≠ va el archivo de la pipeline
‚îú‚îÄ‚îÄ mi_app/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ test_main.py
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ README.md
```
3. Configuraci√≥n de la Pipeline (Archivo python_ci.yml)
Crea el archivo .github/workflows/python_ci.yml y a√±ade el siguiente c√≥digo. Este archivo define la l√≥gica del pipeline.

YAML
```
name: Python CI Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run tests
      run: pytest tests/
```
4. Explicaci√≥n de las Etapas
El archivo YAML se lee de la siguiente manera:

name: El nombre de tu pipeline, que aparecer√° en la interfaz de GitHub Actions.

on: Define los eventos que activar√°n el pipeline. En este caso, un push o una pull_request a la rama main.

jobs: Un pipeline puede tener m√∫ltiples trabajos o jobs. Aqu√≠ solo tenemos uno llamado build.

runs-on: Indica el entorno en el que se ejecutar√° el trabajo. ubuntu-latest es una m√°quina virtual de Ubuntu.

steps: La lista de acciones a realizar, en orden.

actions/checkout@v3: Descarga el c√≥digo de tu repositorio en la m√°quina virtual.

actions/setup-python@v4: Configura la versi√≥n de Python que vas a usar, en este caso, la 3.10.

Install dependencies: Instala las librer√≠as necesarias del archivo requirements.txt.

Run tests: Ejecuta los tests unitarios. Aqu√≠ se asume que usas pytest y que tus tests est√°n en el directorio tests/.

5. ¬øC√≥mo funciona?
Haces cambios en tu c√≥digo y los subes a GitHub con un git push.

GitHub detecta el push a la rama main.

GitHub Actions lee el archivo python_ci.yml y empieza a ejecutar el pipeline.

Cada step se ejecuta en la m√°quina virtual. Si un step falla (por ejemplo, si un test no pasa), el pipeline se detiene y te notifica.

Si todos los steps se ejecutan correctamente, la pipeline pasa con √©xito, lo que te da la confianza de que tus cambios no han roto ninguna funcionalidad existente.

## ejemplo de main.py y test_main.py

Un pipeline es una serie de etapas automatizadas que un desarrollador de software utiliza para entregar c√≥digo nuevo. Este proceso, a menudo llamado Integraci√≥n Continua/Despliegue Continuo (CI/CD), garantiza que el c√≥digo sea probado, construido y desplegado de manera eficiente y confiable. ü§ñ

Ejemplo de Pipeline con Python y GitHub Actions
A continuaci√≥n, te muestro un ejemplo sencillo de c√≥mo configurar una pipeline CI/CD en un proyecto de Python usando GitHub Actions. Este pipeline se activar√° autom√°ticamente cada vez que se haga un push o una pull request a la rama main.

1. Requisitos
Antes de empezar, necesitar√°s:

Un repositorio en GitHub.

Un proyecto de Python en ese repositorio.

Un archivo de requisitos (requirements.txt).

Alg√∫n test unitario, por ejemplo, usando la biblioteca unittest o pytest.

2. Estructura del proyecto
La estructura de tu proyecto de Python deber√≠a ser similar a esta:
```
mi_proyecto_python/
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ python_ci.yml  # Aqu√≠ va el archivo de la pipeline
‚îú‚îÄ‚îÄ mi_app/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ test_main.py
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ README.md
```
3. Configuraci√≥n de la Pipeline (Archivo python_ci.yml)
Crea el archivo .github/workflows/python_ci.yml y a√±ade el siguiente c√≥digo. Este archivo define la l√≥gica del pipeline.

YAML
```
name: Python CI Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run tests
      run: pytest tests/
```
4. Explicaci√≥n de las Etapas
El archivo YAML se lee de la siguiente manera:

name: El nombre de tu pipeline, que aparecer√° en la interfaz de GitHub Actions.

on: Define los eventos que activar√°n el pipeline. En este caso, un push o una pull_request a la rama main.

jobs: Un pipeline puede tener m√∫ltiples trabajos o jobs. Aqu√≠ solo tenemos uno llamado build.

runs-on: Indica el entorno en el que se ejecutar√° el trabajo. ubuntu-latest es una m√°quina virtual de Ubuntu.

steps: La lista de acciones a realizar, en orden.

actions/checkout@v3: Descarga el c√≥digo de tu repositorio en la m√°quina virtual.

actions/setup-python@v4: Configura la versi√≥n de Python que vas a usar, en este caso, la 3.10.

Install dependencies: Instala las librer√≠as necesarias del archivo requirements.txt.

Run tests: Ejecuta los tests unitarios. Aqu√≠ se asume que usas pytest y que tus tests est√°n en el directorio tests/.

5. ¬øC√≥mo funciona?
Haces cambios en tu c√≥digo y los subes a GitHub con un git push.

GitHub detecta el push a la rama main.

GitHub Actions lee el archivo python_ci.yml y empieza a ejecutar el pipeline.

Cada step se ejecuta en la m√°quina virtual. Si un step falla (por ejemplo, si un test no pasa), el pipeline se detiene y te notifica.

Si todos los steps se ejecutan correctamente, la pipeline pasa con √©xito, lo que te da la confianza de que tus cambios no han roto ninguna funcionalidad existente.

Ejemplo de main.py y test_main.py
Para que el pipeline funcione, necesitas tener c√≥digo para probar. A continuaci√≥n, tienes un ejemplo de un archivo main.py con una funci√≥n simple y su correspondiente archivo de prueba test_main.py usando la biblioteca pytest.

main.py
Guarda este archivo en el directorio mi_app/.

Python
```
# mi_app/main.py

def sumar(a, b):
    """
    Esta funci√≥n suma dos n√∫meros.
    """
    return a + b

def restar(a, b):
    """
    Esta funci√≥n resta dos n√∫meros.
    """
    return a - b
```
test_main.py
Guarda este archivo en el directorio tests/.

Python
```
# tests/test_main.py

from mi_app.main import sumar, restar

def test_sumar_numeros_positivos():
    """
    Prueba que la funci√≥n sumar funciona con n√∫meros positivos.
    """
    assert sumar(2, 3) == 5

def test_sumar_numeros_negativos():
    """
    Prueba que la funci√≥n sumar funciona con n√∫meros negativos.
    """
    assert sumar(-1, -1) == -2

def test_restar():
    """
    Prueba que la funci√≥n restar funciona correctamente.
    """
    assert restar(5, 2) == 3
    assert restar(10, 5) == 5

def test_restar_resultado_negativo():
    """
    Prueba que la funci√≥n restar funciona con resultados negativos.
    """
    assert restar(2, 5) == -3
```
¬øQu√© hace este ejemplo?
El archivo main.py contiene dos funciones b√°sicas: sumar y restar.

El archivo test_main.py contiene varias funciones de prueba que verifican el comportamiento de las funciones de main.py usando assert.

Cuando el pipeline de GitHub Actions llega a la etapa Run tests, ejecutar√° pytest tests/, que a su vez encontrar√° y ejecutar√° las funciones de prueba en test_main.py. Si todas las aserciones (assert) son verdaderas, la prueba pasa. Si alguna falla, el pipeline tambi√©n falla.

Este flujo de trabajo simple asegura que cada vez que subes cambios a tu c√≥digo, se comprueba autom√°ticamente que las funciones principales de tu aplicaci√≥n sigan funcionando como se espera.

## Ejemplo de requirements.txt para este ejercicio


Claro, para el ejemplo de pipeline que hemos visto, solo necesitas instalar la biblioteca pytest para poder ejecutar los tests.

requirements.txt
Crea este archivo en la ra√≠z de tu proyecto con el siguiente contenido:

pytest
¬øQu√© hace este archivo?
El archivo requirements.txt es un est√°ndar en proyectos de Python para listar las dependencias del proyecto. En el ejemplo del pipeline, la etapa Install dependencies ejecuta el siguiente comando:

pip install -r requirements.txt
Este comando le dice a pip que instale todas las bibliotecas que se encuentran listadas en el archivo requirements.txt. En este caso, instalar√° pytest, permitiendo que el siguiente paso del pipeline (pytest tests/) se ejecute sin problemas.


## como crear el archivo __init__.py


Un archivo __init__.py es una parte fundamental de los paquetes de Python. Su funci√≥n principal es decirle a Python que un directorio que lo contiene debe ser tratado como un paquete o subpaquete.

En el contexto de tu proyecto, necesitar√°s este archivo en la carpeta mi_app/ para que los tests en tests/test_main.py puedan importar el c√≥digo de mi_app/main.py. Sin √©l, Python no sabr√≠a c√≥mo resolver la importaci√≥n from mi_app.main import sumar, restar.

¬øC√≥mo crearlo?
Simplemente crea un archivo vac√≠o llamado __init__.py dentro del directorio mi_app/.
```
mi_proyecto_python/
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ python_ci.yml
‚îú‚îÄ‚îÄ mi_app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py  # ¬°Aqu√≠ est√°!
‚îÇ   ‚îî‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ test_main.py
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ README.md
```
Contenido del archivo
En muchos casos, el archivo __init__.py puede estar completamente vac√≠o. Solo su presencia es suficiente para que Python lo reconozca como un paquete.

Sin embargo, tambi√©n puedes usarlo para:

Inicializar el paquete: Puedes ejecutar c√≥digo de inicializaci√≥n cuando el paquete es importado.

Exponer funciones o clases: Puedes importar funciones o clases de otros m√≥dulos dentro del paquete para que sean accesibles directamente desde el paquete principal. Por ejemplo, en __init__.py podr√≠as poner:

Python
```
# mi_app/__init__.py
from .main import sumar, restar
```
Con este cambio, podr√≠as importar las funciones de forma m√°s corta en test_main.py:

Python
```
# tests/test_main.py
from mi_app import sumar, restar
```
Para el ejemplo del pipeline, no necesitas agregar ning√∫n contenido. Simplemente crear el archivo vac√≠o en el lugar correcto es suficiente para que las importaciones funcionen y tu pipeline corra con √©xito.
